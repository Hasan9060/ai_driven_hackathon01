---
title: Gazebo Simulation Setup
description: Setting up and configuring Gazebo for robotics simulation environments
sidebar_label: Gazebo Setup
---

# Gazebo Simulation Setup

This module provides comprehensive coverage of Gazebo simulation setup, world creation, physics configuration, and integration with ROS 2. You'll learn to create realistic simulation environments for testing and developing robotics applications.

## Introduction to Gazebo

### What is Gazebo?

Gazebo is a 3D robotics simulator that enables rapid testing of algorithms, design of robots, training of AI systems, and regression testing. It provides physics simulation, sensor simulation, and rendering capabilities for realistic robot behavior.

### Gazebo Versions

**Gazebo Classic:**
- Mature and stable simulation platform
- Extensive plugin ecosystem
- Well-documented and widely used
- Compatible with ROS 2 via gazebo_ros_pkgs

**Gazebo Ignition (Gazebo Sim):**
- Modern architecture with improved performance
- Better sensor simulation capabilities
- Modular design with SDFormat foundation
- Future development focus

### When to Use Each

**Use Gazebo Classic for:**
- Existing ROS 1/2 projects
- Well-supported plugins and sensors
- Educational environments
- Quick prototyping

**Use Gazebo Sim for:**
- New projects requiring advanced features
- High-performance simulation needs
- Complex multi-robot scenarios
- Research with cutting-edge features

## Gazebo Classic Installation

### Ubuntu 22.04 Installation

**Install Gazebo Classic:**
```bash
# Update package lists
sudo apt update

# Install Gazebo Classic
sudo apt install gazebo

# Install Gazebo ROS 2 packages
sudo apt install ros-humble-gazebo-ros-pkgs
sudo apt install ros-humble-ros2-control
sudo apt install ros-humble-ros2-controllers

# Install additional plugins
sudo apt install libgazebo-dev
sudo apt install gazebo11
```

**Verify Installation:**
```bash
# Test Gazebo Classic
gazebo

# Test ROS 2 integration
ros2 run gazebo_ros gazebo_ros2_test.sh
```

### ROS 2 Integration Setup

**Gazebo ROS 2 Bridge:**
```bash
# Install bridge packages
sudo apt install ros-humble-gazebo-ros2-control
sudo apt install ros-humble-gazebo-ros2-interfaces
sudo apt install ros-humble-controller-manager
sudo apt install ros-humble-joint-state-broadcaster
```

**Environment Configuration:**
```bash
# Add to ~/.bashrc
echo "export GAZEBO_MODEL_PATH=$GAZEBO_MODEL_PATH:/usr/share/gazebo-11/models" >> ~/.bashrc
echo "export GAZEBO_PLUGIN_PATH=$GAZEBO_PLUGIN_PATH:/usr/lib/x86_64-linux-gnu/gazebo-11/plugins" >> ~/.bashrc
echo "export GAZEBO_RESOURCE_PATH=$GAZEBO_RESOURCE_PATH:/usr/share/gazebo-11" >> ~/.bashrc

# Source ROS 2
source /opt/ros/humble/setup.bash
```

## Creating Simulation Worlds

### Basic World File Structure

**Simple World File:**
```xml
<?xml version="1.0"?>
<sdf version="1.6">
  <world name="my_world">

    <!-- Physics Engine Configuration -->
    <physics name="1ms" type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1.0</real_time_factor>
      <gravity>0 0 -9.8066</gravity>
    </physics>

    <!-- Ground Plane -->
    <include>
      <uri>model://ground_plane</uri>
    </include>

    <!-- Sun Light -->
    <include>
      <uri>model://sun</uri>
    </include>

  </world>
</sdf>
```

### World Configuration Elements

**Physics Engine Settings:**
```xml
<physics name="default_physics" type="ode">
  <max_step_size>0.001</max_step_size>
  <real_time_factor>1.0</real_time_factor>
  <gravity>0 0 -9.8066</gravity>

  <!-- ODE Solver Configuration -->
  <ode>
    <solver>
      <type>quick</type>
      <iters>10</iters>
      <sor>1.3</sor>
      <use_dynamic_moi_rescaling>0</use_dynamic_moi_rescaling>
    </solver>

    <constraints>
      <cfm>0</cfm>
      <erp>0.2</erp>
      <contact_max_correcting_vel>100</contact_max_correcting_vel>
      <contact_surface_layer>0.001</contact_surface_layer>
    </constraints>
  </ode>
</physics>
```

**Atmospheric and Lighting:**
```xml
<!-- Atmospheric Settings -->
<atmosphere type="adiabatic">
  <temperature>293.15</temperature>
  <pressure>101325</pressure>
  <temperature_gradient>-0.0065</temperature_gradient>
</atmosphere>

<!-- Scene Configuration -->
<scene>
  <ambient>0.4 0.4 0.4 1.0</ambient>
  <background>0.7 0.7 0.7 1.0</background>
  <shadows>true</shadows>
  <grid>false</grid>
</scene>
```

## Loading URDF Models in Gazebo

### ROS 2 Integration Launch File

**Complete Launch File:**
```python
# launch/gazebo_robot.launch.py
from launch import LaunchDescription
from launch.actions import ExecuteProcess, IncludeLaunchDescription
from launch.conditions import IfCondition
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import Command, FindExecutable, LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():

    # Declare launch arguments
    declared_arguments = []
    declared_arguments.append(
        DeclareLaunchArgument(
            'use_sim_time',
            default_value='true',
            description='Use simulation clock'
        )
    )
    declared_arguments.append(
        DeclareLaunchArgument(
            'world_file',
            default_value='',
            description='Gazebo world file path'
        )
    )
    declared_arguments.append(
        DeclareLaunchArgument(
            'robot_description',
            default_value='',
            description='Robot URDF content'
        )
    )

    # Get package directories
    pkg_gazebo_ros = FindPackageShare('gazebo_ros')
    pkg_robot_description = FindPackageShare('my_robot_package')

    # Gazebo launch
    gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(
            PathJoinSubstitution([pkg_gazebo_ros, 'launch', 'gazebo.launch.py'])
        ),
        launch_arguments={'world': LaunchConfiguration('world_file')}.items()
    )

    # Robot state publisher
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        parameters=[{
            'use_sim_time': LaunchConfiguration('use_sim_time'),
            'robot_description': LaunchConfiguration('robot_description')
        }]
    )

    # Spawn robot in Gazebo
    spawn_entity = Node(
        package='gazebo_ros',
        executable='spawn_entity.py',
        arguments=[
            '-entity', 'my_robot',
            '-topic', 'robot_description',
            '-x', '0.0',
            '-y', '0.0',
            '-z', '0.5',
            '-R', '0.0',
            '-P', '0.0',
            '-Y', '0.0'
        ],
        output='screen'
    )

    # Joint state publisher
    joint_state_publisher = Node(
        package='joint_state_publisher',
        executable='joint_state_publisher',
        parameters=[{
            'use_sim_time': LaunchConfiguration('use_sim_time')
        }]
    )

    return LaunchDescription(declared_arguments + [
        gazebo,
        robot_state_publisher,
        spawn_entity,
        joint_state_publisher
    ])
```

### Robot Description with Gazebo Tags

**Enhanced URDF for Gazebo:**
```xml
<?xml version="1.0"?>
<robot name="my_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">

  <!-- Base Link -->
  <link name="base_link">
    <inertial>
      <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
      <mass value="10.0"/>
      <inertia ixx="0.1" ixy="0.0" ixz="0.0"
               iyy="0.1" iyz="0.0"
               izz="0.1"/>
    </inertial>

    <visual>
      <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
      <geometry>
        <box size="0.5 0.3 0.1"/>
      </geometry>
      <material name="blue_material">
        <color rgba="0.0 0.0 1.0 1.0"/>
      </material>
    </visual>

    <collision>
      <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
      <geometry>
        <box size="0.5 0.3 0.1"/>
      </geometry>
      <surface>
        <friction>
          <ode>
            <mu>0.6</mu>
            <mu2>0.6</mu2>
          </ode>
        </friction>
      </surface>
    </collision>
  </link>

  <!-- Gazebo-specific properties -->
  <gazebo reference="base_link">
    <material>Gazebo/Blue</material>
    <turnGravityOff>false</turnGravityOff>
    <selfCollide>false</selfCollide>
  </gazebo>

  <!-- Wheel -->
  <link name="left_wheel">
    <inertial>
      <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
      <mass value="1.0"/>
      <inertia ixx="0.01" ixy="0.0" ixz="0.0"
               iyy="0.01" iyz="0.0"
               izz="0.01"/>
    </inertial>

    <visual>
      <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
      <material name="black_material">
        <color rgba="0.0 0.0 0.0 1.0"/>
      </material>
    </visual>

    <collision>
      <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
    </collision>
  </link>

  <!-- Wheel Joint -->
  <joint name="left_wheel_joint" type="continuous">
    <parent link="base_link"/>
    <child link="left_wheel"/>
    <origin xyz="0.15 0.2 0.0" rpy="1.5708 0.0 0.0"/>
    <axis xyz="0.0 0.0 1.0"/>
  </joint>

  <!-- Gazebo wheel properties -->
  <gazebo reference="left_wheel">
    <material>Gazebo/Black</material>
    <mu1 value="1.0"/>
    <mu2 value="1.0"/>
    <fdir1 value="1 0 0"/>
    <ode>
      <slip1 value="0.0"/>
      <slip2 value="0.0"/>
    </ode>
  </gazebo>

  <!-- Differential drive plugin -->
  <gazebo>
    <plugin name="diff_drive_plugin" filename="libgazebo_ros_diff_drive.so">

      <!-- Robot base link -->
      <ros>
        <namespace>/</namespace>
        <remapping>cmd_vel:=cmd_vel</remapping>
        <remapping>odom:=odom</remapping>
      </ros>

      <!-- Wheels -->
      <left_joint>left_wheel_joint</left_joint>
      <right_joint>right_wheel_joint</right_joint>

      <!-- Wheel separation and diameter -->
      <wheel_separation>0.4</wheel_separation>
      <wheel_diameter>0.2</wheel_diameter>

      <!-- Limits -->
      <max_wheel_torque>20</max_wheel_torque>
      <max_wheel_acceleration>1.0</max_wheel_acceleration>

      <!-- Odometry -->
      <publish_odom>true</publish_odom>
      <publish_odom_tf>true</publish_odom_tf>
      <publish_wheel_tf>true</publish_wheel_tf>

      <odometry_frame>odom</odometry_frame>
      <robot_base_frame>base_link</robot_base_frame>

    </plugin>
  </gazebo>

</robot>
```

## Sensor Simulation

### Camera Sensor

**Camera Plugin Configuration:**
```xml
<!-- Camera Link -->
<link name="camera_link">
  <inertial>
    <origin xyz="0.0 0.0 0.0"/>
    <mass value="0.1"/>
    <inertia ixx="0.001" ixy="0.0" ixz="0.0"
             iyy="0.001" iyz="0.0"
             izz="0.001"/>
  </inertial>

  <visual>
    <geometry>
      <box size="0.05 0.05 0.05"/>
    </geometry>
    <material name="camera_material">
      <color rgba="0.0 0.0 0.0 1.0"/>
    </material>
  </visual>
</link>

<!-- Camera Joint -->
<joint name="camera_joint" type="fixed">
  <parent link="base_link"/>
  <child link="camera_link"/>
  <origin xyz="0.1 0.0 0.2" rpy="0.0 0.0 0.0"/>
</joint>

<!-- Camera Sensor Plugin -->
<gazebo reference="camera_link">
  <sensor type="camera" name="camera_sensor">
    <pose>0 0 0 0 0 0</pose>
    <camera>
      <horizontal_fov>1.047</horizontal_fov>
      <image>
        <width>640</width>
        <height>480</height>
        <format>R8G8B8</format>
      </image>
      <clip>
        <near>0.1</near>
        <far>100</far>
      </clip>
    </camera>

    <always_on>true</always_on>
    <update_rate>30</update_rate>
    <visualize>true</visualize>

    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">
      <ros>
        <namespace>/camera</namespace>
        <remapping>image_raw:=image_raw</remapping>
        <remapping>camera_info:=camera_info</remapping>
      </ros>
      <camera_name>camera</camera_name>
      <frame_name>camera_link</frame_name>
      <hack_baseline>0.07</hack_baseline>
    </plugin>
  </sensor>
</gazebo>
```

### LiDAR Sensor

**LiDAR Plugin Configuration:**
```xml
<!-- LiDAR Link -->
<link name="laser_link">
  <inertial>
    <origin xyz="0.0 0.0 0.0"/>
    <mass value="0.5"/>
    <inertia ixx="0.001" ixy="0.0" ixz="0.0"
             iyy="0.001" iyz="0.0"
             izz="0.001"/>
  </inertial>

  <visual>
    <geometry>
      <cylinder radius="0.05" length="0.1"/>
    </geometry>
    <material name="laser_material">
      <color rgba="1.0 0.0 0.0 1.0"/>
    </material>
  </visual>
</link>

<!-- LiDAR Joint -->
<joint name="laser_joint" type="fixed">
  <parent link="base_link"/>
  <child link="laser_link"/>
  <origin xyz="0.0 0.0 0.3" rpy="0.0 0.0 0.0"/>
</joint>

<!-- LiDAR Sensor Plugin -->
<gazebo reference="laser_link">
  <sensor type="ray" name="laser_sensor">
    <pose>0 0 0 0 0 0</pose>

    <ray>
      <scan>
        <horizontal>
          <samples>360</samples>
          <resolution>1</resolution>
          <min_angle>-3.14159</min_angle>
          <max_angle>3.14159</max_angle>
        </horizontal>
      </scan>

      <range>
        <min>0.1</min>
        <max>10.0</max>
        <resolution>0.01</resolution>
      </range>
    </ray>

    <plugin name="laser_controller" filename="libgazebo_ros_ray_sensor.so">
      <ros>
        <namespace>/laser</namespace>
        <remapping>scan:=scan</remapping>
      </ros>
      <output_type>sensor_msgs/LaserScan</output_type>
      <frame_name>laser_link</frame_name>
    </plugin>

    <always_on>true</always_on>
    <update_rate>10</update_rate>
    <visualize>true</visualize>
  </sensor>
</gazebo>
```

### IMU Sensor

**IMU Plugin Configuration:**
```xml
<!-- IMU Link -->
<link name="imu_link">
  <inertial>
    <origin xyz="0.0 0.0 0.0"/>
    <mass value="0.05"/>
    <inertia ixx="0.0001" ixy="0.0" ixz="0.0"
             iyy="0.0001" iyz="0.0"
             izz="0.0001"/>
  </inertial>

  <visual>
    <geometry>
      <box size="0.02 0.02 0.01"/>
    </geometry>
    <material name="imu_material">
      <color rgba="0.0 1.0 0.0 1.0"/>
    </material>
  </visual>
</link>

<!-- IMU Joint -->
<joint name="imu_joint" type="fixed">
  <parent link="base_link"/>
  <child link="imu_link"/>
  <origin xyz="0.0 0.0 0.05" rpy="0.0 0.0 0.0"/>
</joint>

<!-- IMU Sensor Plugin -->
<gazebo reference="imu_link">
  <sensor type="imu" name="imu_sensor">
    <pose>0 0 0 0 0 0</pose>

    <always_on>true</always_on>
    <update_rate>100</update_rate>
    <visualize>true</visualize>

    <imu>
      <angular_velocity>
        <x>
          <noise type="gaussian">
            <mean>0.0</mean>
            < stddev>2e-3</stddev>
            <bias_mean>0.000005</bias_mean>
            <bias_stddev>0.00005</bias_stddev>
          </noise>
        </x>
        <y>
          <noise type="gaussian">
            <mean>0.0</mean>
            < stddev>2e-3</stddev>
            <bias_mean>0.000005</bias_mean>
            <bias_stddev>0.00005</bias_stddev>
          </noise>
        </y>
        <z>
          <noise type="gaussian">
            <mean>0.0</mean>
            < stddev>2e-3</stddev>
            <bias_mean>0.000005</bias_mean>
            <bias_stddev>0.00005</bias_stddev>
          </noise>
        </z>
      </angular_velocity>

      <linear_acceleration>
        <x>
          <noise type="gaussian">
            <mean>0.0</mean>
            < stddev>1.7e-2</stddev>
            <bias_mean>0.1</bias_mean>
            <bias_stddev>0.001</bias_stddev>
          </noise>
        </x>
        <y>
          <noise type="gaussian">
            <mean>0.0</mean>
            < stddev>1.7e-2</stddev>
            <bias_mean>0.1</bias_mean>
            <bias_stddev>0.001</bias_stddev>
          </noise>
        </y>
        <z>
          <noise type="gaussian">
            <mean>0.0</mean>
            < stddev>1.7e-2</stddev>
            <bias_mean>0.1</bias_mean>
            <bias_stddev>0.001</bias_stddev>
          </noise>
        </z>
      </linear_acceleration>
    </imu>

    <plugin name="imu_controller" filename="libgazebo_ros_imu.so">
      <ros>
        <namespace>/imu</namespace>
        <remapping>~/ imu:=/imu/data</remapping>
      </ros>
      <initial_orientation_as_reference>false</initial_orientation_as_reference>
    </plugin>
  </sensor>
</gazebo>
```

## Advanced Simulation Features

### Physics Plugins and Materials

**Custom Material Properties:**
```xml
<gazebo reference="wheel_link">
  <material>Gazebo/Grey</material>
  <mu1>1.0</mu1>
  <mu2>1.0</mu2>
  <slip1>0.0</slip1>
  <slip2>0.0</slip2>
  <elastic_modulus>1e+7</elastic_modulus>
  <poisson_ratio>0.3</poisson_ratio>
  <restitution_coef>0.5</restitution_coef>
  <rolling_friction>1.0</rolling_friction>
  <stiffness>1000000</stiffness>
  <damping>1.0</damping>
</gazebo>
```

**Contact Sensors:**
```xml
<gazebo reference="bumper_link">
  <sensor type="contact" name="bumper_contact">
    <contact>
      <collision>bumper_collision</collision>
    </contact>

    <plugin name="bumper_plugin" filename="libgazebo_ros_bumper.so">
      <ros>
        <namespace>/bumper</namespace>
        <remapping>bumper_states:=bumper_states</remapping>
      </ros>
      <frame_name>bumper_link</frame_name>
    </plugin>

    <always_on>true</always_on>
    <update_rate>10</update_rate>
  </sensor>
</gazebo>
```

### World Generation with Python

**Python World Generator:**
```python
#!/usr/bin/env python3

import math
import random
from lxml import etree

class GazeboWorldGenerator:
    def __init__(self, world_name="generated_world"):
        self.world_name = world_name
        self.sdf = etree.Element("sdf", version="1.6")
        self.world = etree.SubElement(self.sdf, "world", name=world_name)

        # Add basic elements
        self.add_physics()
        self.add_ground_plane()
        self.add_sun()
        self.add_sky()

    def add_physics(self):
        """Add physics engine configuration"""
        physics = etree.SubElement(self.world, "physics", name="default_physics", type="ode")

        etree.SubElement(physics, "max_step_size").text = "0.001"
        etree.SubElement(physics, "real_time_factor").text = "1.0"

        gravity = etree.SubElement(physics, "gravity")
        gravity.text = "0 0 -9.8066"

        # ODE solver
        ode = etree.SubElement(physics, "ode")
        solver = etree.SubElement(ode, "solver")
        etree.SubElement(solver, "type").text = "quick"
        etree.SubElement(solver, "iters").text = "10"
        etree.SubElement(solver, "sor").text = "1.3"

    def add_ground_plane(self):
        """Add ground plane"""
        include = etree.SubElement(self.world, "include")
        etree.SubElement(include, "uri").text = "model://ground_plane"

    def add_sun(self):
        """Add sun light"""
        include = etree.SubElement(self.world, "include")
        etree.SubElement(include, "uri").text = "model://sun"

    def add_sky(self):
        """Add sky and atmosphere"""
        sky = etree.SubElement(self.world, "sky")
        etree.SubElement(sky, "time").text = "10"
        etree.SubElement(sky, "sunrise").text = "6"
        etree.SubElement(sky, "sunset").text = "20"
        etree.SubElement(sky, "clouds").text = "0.3"

        atmosphere = etree.SubElement(self.world, "atmosphere", type="adiabatic")
        etree.SubElement(atmosphere, "temperature").text = "293.15"
        etree.SubElement(atmosphere, "pressure").text = "101325"

    def add_box(self, name, position, size, color="Gazebo/Red"):
        """Add a box obstacle"""
        include = etree.SubElement(self.world, "include")
        etree.SubElement(include, "uri").text = "model://unit_box"

        pose = f"{position[0]} {position[1]} {position[2]} 0 0 0"
        etree.SubElement(include, "pose").text = pose

        name_elem = etree.SubElement(include, "name")
        name_elem.text = name

    def add_cylinder(self, name, position, radius, height, color="Gazebo/Blue"):
        """Add a cylinder obstacle"""
        include = etree.SubElement(self.world, "include")
        etree.SubElement(include, "uri").text = "model://unit_cylinder"

        pose = f"{position[0]} {position[1]} {position[2]} 0 0 0"
        etree.SubElement(include, "pose").text = pose

        name_elem = etree.SubElement(include, "name")
        name_elem.text = name

        # Scale the cylinder
        scale = f"{radius} {radius} {height}"
        etree.SubElement(include, "scale").text = scale

    def generate_maze(self, rows=5, cols=5, cell_size=2.0):
        """Generate a simple maze"""
        wall_height = 2.0
        wall_thickness = 0.1

        # Generate maze using simple algorithm
        maze = self.generate_maze_pattern(rows, cols)

        # Add walls based on maze pattern
        for i in range(rows):
            for j in range(cols):
                x = i * cell_size
                z = j * cell_size

                if maze[i][j] == 1:
                    # Add wall at this position
                    self.add_box(
                        f"wall_{i}_{j}",
                        [x, wall_height/2, z],
                        [cell_size - wall_thickness, wall_height, cell_size - wall_thickness]
                    )

    def generate_maze_pattern(self, rows, cols):
        """Generate a simple maze pattern"""
        # Simple checkerboard pattern for demonstration
        maze = [[0 for _ in range(cols)] for _ in range(rows)]

        for i in range(rows):
            for j in range(cols):
                if i == 0 or i == rows-1 or j == 0 or j == cols-1:
                    maze[i][j] = 1  # Border walls
                elif random.random() < 0.3:
                    maze[i][j] = 1  # Random walls

        return maze

    def add_random_obstacles(self, num_obstacles=10):
        """Add random box obstacles"""
        for i in range(num_obstacles):
            x = random.uniform(-10, 10)
            z = random.uniform(-10, 10)
            y = 0.5  # Slightly above ground

            size_x = random.uniform(0.5, 2.0)
            size_y = random.uniform(0.5, 2.0)
            size_z = random.uniform(0.5, 2.0)

            self.add_box(
                f"obstacle_{i}",
                [x, y, z],
                [size_x, size_y, size_z]
            )

    def save_world(self, filename):
        """Save world to SDF file"""
        tree = etree.ElementTree(self.sdf)
        tree.write(filename, pretty_print=True, xml_declaration=True, encoding="utf-8")

# Usage example
if __name__ == "__main__":
    generator = GazeboWorldGenerator("test_world")
    generator.generate_maze(8, 8, 2.0)
    generator.add_random_obstacles(15)
    generator.save_world("generated_world.sdf")
    print(f"Generated world saved to generated_world.sdf")
```

## Testing and Debugging

### Common Issues and Solutions

**1. Robot Falls Through Ground:**
```xml
<!-- Problem: No collision geometry -->
<visual>
  <geometry>
    <box size="0.5 0.3 0.1"/>
  </geometry>
</visual>

<!-- Solution: Add collision geometry -->
<collision>
  <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
  <geometry>
    <box size="0.5 0.3 0.1"/>
  </geometry>
</collision>
```

**2. Incorrect Inertia Properties:**
```xml
<!-- Problem: Zero inertia -->
<inertial>
  <mass value="10.0"/>
  <inertia ixx="0.0" ixy="0.0" ixz="0.0"
           iyy="0.0" iyz="0.0"
           izz="0.0"/>
</inertial>

<!-- Solution: Calculate proper inertia -->
<inertial>
  <mass value="10.0"/>
  <inertia ixx="0.1" ixy="0.0" ixz="0.0"
           iyy="0.1" iyz="0.0"
           izz="0.1"/>
</inertial>
```

**3. Plugin Loading Issues:**
```bash
# Check plugin path
echo $GAZEBO_PLUGIN_PATH

# Test plugin loading
gazebo --verbose -s libgazebo_ros_diff_drive.so

# Check ROS 2 bridge
ros2 run gazebo_ros gazebo_ros2_test.sh
```

### Performance Optimization

**Simulation Performance Tips:**
```xml
<!-- Use simplified collision meshes -->
<collision>
  <geometry>
    <box size="0.5 0.3 0.1"/>  <!-- Simple geometry for physics -->
  </geometry>
</collision>

<visual>
  <geometry>
    <mesh filename="detailed_mesh.stl"/>  <!-- Detailed mesh for visualization -->
  </geometry>
</visual>

<!-- Optimize physics settings -->
<physics name="optimized" type="ode">
  <max_step_size>0.002</max_step_size>  <!-- Larger step size -->
  <real_time_factor>0.5</real_time_factor>  <!-- Allow slower than real-time -->

  <ode>
    <solver>
      <iters>5</iters>  <!-- Fewer iterations -->
    </solver>
  </ode>
</physics>
```

**GPU Acceleration:**
```xml
<!-- Enable GPU rendering -->
<gui>
  <camera name="user_camera">
    <image_size>640 480</image_size>
    <visible>true</visible>
  </camera>
</gui>

<rendering>
  <engine>ogre</engine>
  <grid>true</grid>
  <shadows>true</shadows>
</rendering>
```

## Best Practices

### World Design Guidelines

**1. Start Simple:**
```xml
<!-- Begin with basic world -->
<sdf version="1.6">
  <world name="simple_world">
    <physics type="ode"/>
    <include><uri>model://ground_plane</uri></include>
    <include><uri>model://sun</uri></include>
  </world>
</sdf>
```

**2. Add Complexity Gradually:**
- Add one element at a time
- Test after each addition
- Use known working models first

**3. Optimize for Performance:**
- Use simple collision geometry
- Limit sensor update rates
- Adjust physics parameters

### Launch File Organization

**Modular Launch Structure:**
```python
# launch/simulation.launch.py
def generate_launch_description():
    return LaunchDescription([
        # World-specific launch
        IncludeLaunchDescription(
            PythonLaunchDescriptionSource([
                get_package_share_directory('my_package'),
                'launch',
                'worlds',
                'office_world.launch.py'
            ])
        ),

        # Robot-specific launch
        IncludeLaunchDescription(
            PythonLaunchDescriptionSource([
                get_package_share_directory('my_package'),
                'launch',
                'robots',
                'mobile_robot.launch.py'
            ])
        ),

        # Sensor-specific launch
        IncludeLaunchDescription(
            PythonLaunchDescriptionSource([
                get_package_share_directory('my_package'),
                'launch',
                'sensors',
                'camera_laser.launch.py'
            ])
        )
    ])
```

### Version Control and Collaboration

**Project Structure:**
```
my_robot_package/
├── worlds/
│   ├── empty_world.sdf
│   ├── office_world.sdf
│   └── outdoor_world.sdf
├── models/
│   ├── custom_box/
│   ├── custom_obstacle/
│   └── environment_objects/
├── launch/
│   ├── simulation.launch.py
│   ├── worlds/
│   └── robots/
├── urdf/
│   └── my_robot.urdf
├── config/
│   ├── gazebo_params.yaml
│   └── simulation_config.yaml
└── scripts/
    ├── generate_world.py
    └── test_simulation.py
```

## Next Steps

This comprehensive guide to Gazebo simulation setup provides the foundation for creating realistic robotics simulation environments. The next sections will cover:

1. **Advanced Sensor Modeling**: Detailed sensor simulation and calibration
2. **Unity Integration**: High-fidelity visualization and rendering
3. **Multi-Robot Simulation**: Complex multi-agent scenarios
4. **Sim-to-Real Transfer**: Bridging simulation and physical robots

By mastering these Gazebo simulation techniques, you'll be equipped to create sophisticated test environments for robotics development, research, and education.