---
title: URDF and Robot Modeling
description: Creating and using Unified Robot Description Format (URDF) for robot modeling
sidebar_label: URDF Robot Modeling
---

# URDF and Robot Modeling

This module provides comprehensive coverage of the Unified Robot Description Format (URDF) and robot modeling techniques for creating accurate virtual robot representations. You'll learn to build complete robot models with proper kinematics, dynamics, visual properties, and sensor integration.

## Introduction to URDF

### What is URDF?

The Unified Robot Description Format (URDF) is an XML format for representing a robot model. It's the standard way to describe robot geometry, kinematics, dynamics, and visual properties in ROS 2.

### Key URDF Components

**Links:**
- Rigid bodies that make up the robot
- Define inertial, visual, and collision properties
- Can have parent-child relationships via joints

**Joints:**
- Connections between links
- Define degrees of freedom and motion constraints
- Support various joint types (revolute, prismatic, fixed, etc.)

**Materials:**
- Define visual properties (colors, textures)
- Support both colors and texture mapping

## Basic URDF Structure

### URDF File Format

**Minimal URDF Structure:**
```xml
<?xml version="1.0"?>
<robot name="my_robot">
  <!-- Links and joints go here -->
</robot>
```

**Complete Robot Example:**
```xml
<?xml version="1.0"?>
<robot name="mobile_robot">
  <!-- Base Link -->
  <link name="base_link">
    <inertial>
      <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
      <mass value="10.0"/>
      <inertia ixx="0.1" ixy="0.0" ixz="0.0"
               iyy="0.1" iyz="0.0"
               izz="0.1"/>
    </inertial>

    <visual>
      <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
      <geometry>
        <box size="0.5 0.3 0.1"/>
      </geometry>
      <material name="blue_material">
        <color rgba="0.0 0.0 1.0 1.0"/>
      </material>
    </visual>

    <collision>
      <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
      <geometry>
        <box size="0.5 0.3 0.1"/>
      </geometry>
    </collision>
  </link>

  <!-- Wheel Joint -->
  <joint name="left_wheel_joint" type="continuous">
    <parent link="base_link"/>
    <child link="left_wheel"/>
    <origin xyz="0.15 0.2 0.0" rpy="1.5708 0.0 0.0"/>
    <axis xyz="0.0 0.0 1.0"/>
  </joint>

  <!-- Wheel Link -->
  <link name="left_wheel">
    <inertial>
      <origin xyz="0.0 0.0 0.0"/>
      <mass value="1.0"/>
      <inertia ixx="0.01" ixy="0.0" ixz="0.0"
               iyy="0.01" iyz="0.0"
               izz="0.01"/>
    </inertial>

    <visual>
      <origin xyz="0.0 0.0 0.0"/>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
      <material name="black_material">
        <color rgba="0.0 0.0 0.0 1.0"/>
      </material>
    </visual>

    <collision>
      <origin xyz="0.0 0.0 0.0"/>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
    </collision>
  </link>
</robot>
```

## Link Definitions

### Inertial Properties

**Mass and Inertia:**
```xml
<inertial>
  <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
  <mass value="5.0"/>
  <inertia ixx="0.1" ixy="0.0" ixz="0.0"
           iyy="0.1" iyz="0.0"
           izz="0.1"/>
</inertial>
```

**Inertia Matrix Explanation:**
- `ixx`, `iyy`, `izz`: Moments of inertia around principal axes
- `ixy`, `ixz`, `iyz`: Products of inertia
- For simple shapes, can use standard formulas or calculators

**Common Inertia Calculations:**

**Box Inertia:**
```
ixx = (mass/12) * (height² + depth²)
iyy = (mass/12) * (width² + depth²)
izz = (mass/12) * (width² + height²)
```

**Cylinder Inertia:**
```
ixx = iyy = (mass/12) * (3*radius² + height²)
izz = (mass/2) * radius²
```

**Sphere Inertia:**
```
ixx = iyy = izz = (2/5) * mass * radius²
```

### Visual Properties

**Basic Visual Geometry:**
```xml
<visual>
  <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
  <geometry>
    <box size="1.0 0.5 0.2"/>
  </geometry>
  <material name="red_material">
    <color rgba="1.0 0.0 0.0 1.0"/>
  </material>
</visual>
```

**Supported Geometry Types:**

**Box:**
```xml
<geometry>
  <box size="width depth height"/>
</geometry>
```

**Cylinder:**
```xml
<geometry>
  <cylinder radius="0.5" length="1.0"/>
</geometry>
```

**Sphere:**
```xml
<geometry>
  <sphere radius="0.5"/>
</geometry>
```

**Mesh:**
```xml
<geometry>
  <mesh filename="package://my_robot_package/modes/wheel.stl"
        scale="1.0 1.0 1.0"/>
</geometry>
```

**Advanced Materials:**
```xml
<material name="metal_material">
  <color rgba="0.7 0.7 0.7 1.0"/>
  <texture filename="package://my_robot_package/textures/metal.jpg"/>
</material>
```

### Collision Properties

**Collision Geometry:**
```xml
<collision>
  <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
  <geometry>
    <box size="1.0 0.5 0.2"/>
  </geometry>
  <contact_coefficients mu="0.6" kp="1000.0" kd="1.0"/>
</collision>
```

**Contact Coefficients:**
- `mu`: Friction coefficient (0.0-1.0)
- `kp`: Stiffness coefficient
- `kd`: Damping coefficient

## Joint Definitions

### Joint Types

**Revolute Joint (Rotational):**
```xml
<joint name="elbow_joint" type="revolute">
  <parent link="upper_arm"/>
  <child link="forearm"/>
  <origin xyz="0.0 0.0 0.25" rpy="0.0 0.0 0.0"/>
  <axis xyz="0.0 1.0 0.0"/>
  <limit lower="-1.57" upper="1.57" effort="100" velocity="1.0"/>
</joint>
```

**Prismatic Joint (Linear):**
```xml
<joint name="linear_joint" type="prismatic">
  <parent link="base"/>
  <child link="slider"/>
  <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
  <axis xyz="0.0 0.0 1.0"/>
  <limit lower="0.0" upper="1.0" effort="50" velocity="0.5"/>
</joint>
```

**Continuous Joint (Unlimited Rotation):**
```xml
<joint name="wheel_joint" type="continuous">
  <parent link="base"/>
  <child link="wheel"/>
  <origin xyz="0.15 0.0 0.0" rpy="1.5708 0.0 0.0"/>
  <axis xyz="0.0 0.0 1.0"/>
  <limit effort="50" velocity="5.0"/>
</joint>
```

**Fixed Joint (No Movement):**
```xml
<joint name="sensor_mount" type="fixed">
  <parent link="base"/>
  <child link="sensor"/>
  <origin xyz="0.0 0.0 0.5" rpy="0.0 0.0 0.0"/>
</joint>
```

**Floating Joint (6 DOF):**
```xml
<joint name="floating_joint" type="floating">
  <parent link="world"/>
  <child link="base"/>
  <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
</joint>
```

### Joint Limits and Dynamics

**Joint Limits:**
```xml
<limit
  lower="-1.57"     <!-- Lower bound (radians) -->
  upper="1.57"      <!-- Upper bound (radians) -->
  effort="100.0"    <!-- Maximum effort (N·m for revolute, N for prismatic) -->
  velocity="1.0"/>  <!-- Maximum velocity (rad/s or m/s) -->
```

**Joint Dynamics:**
```xml
<dynamics
  damping="0.1"     <!-- Joint damping (N·m·s/rad or N·s/m) -->
  friction="0.0"/>  <!-- Joint friction (N·m or N) -->
```

**Calibration:**
```xml
<calibration
  rising="0.0"      <!-- Position when encoder increases -->
  falling="0.0"/>   <!-- Position when encoder decreases -->
```

## Advanced URDF Features

### Xacro for Modular URDF

**Xacro Definition:**
```xml
<?xml version="1.0"?>
<robot name="my_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">

  <!-- Define properties -->
  <xacro:property name="wheel_radius" value="0.1"/>
  <xacro:property name="wheel_length" value="0.05"/>
  <xacro:property name="base_width" value="0.5"/>
  <xacro:property name="base_length" value="0.3"/>

  <!-- Define macro for wheel -->
  <xacro:macro name="wheel" prefix="left">
    <link name="${prefix}_wheel">
      <inertial>
        <origin xyz="0.0 0.0 0.0"/>
        <mass value="1.0"/>
        <inertia ixx="0.01" ixy="0.0" ixz="0.0"
                 iyy="0.01" iyz="0.0"
                 izz="0.01"/>
      </inertial>

      <visual>
        <origin xyz="0.0 0.0 0.0"/>
        <geometry>
          <cylinder radius="${wheel_radius}" length="${wheel_length}"/>
        </geometry>
        <material name="black_material">
          <color rgba="0.0 0.0 0.0 1.0"/>
        </material>
      </visual>

      <collision>
        <origin xyz="0.0 0.0 0.0"/>
        <geometry>
          <cylinder radius="${wheel_radius}" length="${wheel_length}"/>
        </geometry>
      </collision>
    </link>

    <joint name="${prefix}_wheel_joint" type="continuous">
      <parent link="base_link"/>
      <child link="${prefix}_wheel"/>
      <origin xyz="${base_width/2} ${prefix == 'left' ? base_width/2 : -base_width/2} 0.0"
              rpy="1.5708 0.0 0.0"/>
      <axis xyz="0.0 0.0 1.0"/>
    </joint>
  </xacro:macro>

  <!-- Use macro to create wheels -->
  <xacro:wheel prefix="left"/>
  <xacro:wheel prefix="right"/>

</robot>
```

### Sensor Integration

**Camera Sensor:**
```xml
<joint name="camera_joint" type="fixed">
  <parent link="base_link"/>
  <child link="camera_link"/>
  <origin xyz="0.1 0.0 0.2" rpy="0.0 0.0 0.0"/>
</joint>

<link name="camera_link">
  <inertial>
    <origin xyz="0.0 0.0 0.0"/>
    <mass value="0.1"/>
    <inertia ixx="0.001" ixy="0.0" ixz="0.0"
             iyy="0.001" iyz="0.0"
             izz="0.001"/>
  </inertial>

  <visual>
    <origin xyz="0.0 0.0 0.0"/>
    <geometry>
      <box size="0.05 0.05 0.05"/>
    </geometry>
    <material name="camera_material">
      <color rgba="0.0 0.0 0.0 1.0"/>
    </material>
  </visual>
</link>

<!-- Camera optical frame for correct image orientation -->
<joint name="camera_optical_joint" type="fixed">
  <parent link="camera_link"/>
  <child link="camera_optical_frame"/>
  <origin xyz="0.0 0.0 0.0" rpy="-1.5708 0.0 -1.5708"/>
</joint>

<link name="camera_optical_frame"/>
```

**LiDAR Sensor:**
```xml
<joint name="laser_joint" type="fixed">
  <parent link="base_link"/>
  <child link="laser_link"/>
  <origin xyz="0.0 0.0 0.3" rpy="0.0 0.0 0.0"/>
</joint>

<link name="laser_link">
  <inertial>
    <origin xyz="0.0 0.0 0.0"/>
    <mass value="0.5"/>
    <inertia ixx="0.001" ixy="0.0" ixz="0.0"
             iyy="0.001" iyz="0.0"
             izz="0.001"/>
  </inertial>

  <visual>
    <origin xyz="0.0 0.0 0.0"/>
    <geometry>
      <cylinder radius="0.05" length="0.1"/>
    </geometry>
    <material name="laser_material">
      <color rgba="1.0 0.0 0.0 1.0"/>
    </material>
  </visual>

  <collision>
    <origin xyz="0.0 0.0 0.0"/>
    <geometry>
      <cylinder radius="0.05" length="0.1"/>
    </geometry>
  </collision>
</link>
```

**IMU Sensor:**
```xml
<joint name="imu_joint" type="fixed">
  <parent link="base_link"/>
  <child link="imu_link"/>
  <origin xyz="0.0 0.0 0.05" rpy="0.0 0.0 0.0"/>
</joint>

<link name="imu_link">
  <inertial>
    <origin xyz="0.0 0.0 0.0"/>
    <mass value="0.05"/>
    <inertia ixx="0.0001" ixy="0.0" ixz="0.0"
             iyy="0.0001" iyz="0.0"
             izz="0.0001"/>
  </inertial>

  <visual>
    <origin xyz="0.0 0.0 0.0"/>
    <geometry>
      <box size="0.02 0.02 0.01"/>
    </geometry>
    <material name="imu_material">
      <color rgba="0.0 1.0 0.0 1.0"/>
    </material>
  </visual>
</link>
```

## Robot State Publisher

### Launch Configuration

**Basic State Publisher Launch:**
```python
# launch/robot_state_publisher.launch.py
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.substitutions import FindExecutable
from launch.substitutions import PathJoinSubstitution
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():
    package_name = 'my_robot_package'

    return LaunchDescription([
        Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            name='robot_state_publisher',
            parameters=[{
                'robot_description': PathJoinSubstitution([
                    get_package_share_directory(package_name),
                    'urdf',
                    'my_robot.urdf'
                ])
            }],
            output='screen'
        ),

        Node(
            package='joint_state_publisher',
            executable='joint_state_publisher',
            name='joint_state_publisher',
            parameters=[{
                'use_gui': True
            }]
        ),

        Node(
            package='rviz2',
            executable='rviz2',
            name='rviz2',
            arguments=['-d', PathJoinSubstitution([
                get_package_share_directory(package_name),
                'config',
                'robot_config.rviz'
            ])]
        )
    ])
```

### Joint State Publisher

**Manual Joint State Publishing:**
```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState

class JointStatePublisher(Node):
    def __init__(self):
        super().__init__('manual_joint_state_publisher')

        self.publisher = self.create_publisher(
            JointState, '/joint_states', 10
        )

        self.timer = self.create_timer(0.1, self.publish_joint_states)

        # Initialize joint positions
        self.joint_positions = {
            'left_wheel_joint': 0.0,
            'right_wheel_joint': 0.0,
            'elbow_joint': 0.0
        }

        self.time = 0.0

    def publish_joint_states(self):
        msg = JointState()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.name = list(self.joint_positions.keys())
        msg.position = list(self.joint_positions.values())

        # Simulate movement
        self.joint_positions['left_wheel_joint'] = 0.5 * self.time
        self.joint_positions['right_wheel_joint'] = 0.5 * self.time
        self.joint_positions['elbow_joint'] = 0.5 * math.sin(self.time)

        self.publisher.publish(msg)
        self.time += 0.1

def main():
    rclpy.init()
    node = JointStatePublisher()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Kinematics and Dynamics

### Forward Kinematics

**Robot Arm Example:**
```xml
<!-- 3-DOF Robot Arm -->
<robot name="robot_arm">
  <!-- Base Link -->
  <link name="base_link">
    <inertial>
      <origin xyz="0.0 0.0 0.0"/>
      <mass value="10.0"/>
      <inertia ixx="0.1" ixy="0.0" ixz="0.0"
               iyy="0.1" iyz="0.0"
               izz="0.1"/>
    </inertial>
    <visual>
      <geometry>
        <cylinder radius="0.1" length="0.2"/>
      </geometry>
    </visual>
  </link>

  <!-- Link 1 -->
  <link name="link1">
    <inertial>
      <origin xyz="0.0 0.0 0.25"/>
      <mass value="5.0"/>
      <inertia ixx="0.05" ixy="0.0" ixz="0.0"
               iyy="0.05" iyz="0.0"
               izz="0.05"/>
    </inertial>
    <visual>
      <origin xyz="0.0 0.0 0.25"/>
      <geometry>
        <cylinder radius="0.05" length="0.5"/>
      </geometry>
    </visual>
  </link>

  <!-- Joint 1 (Base rotation) -->
  <joint name="joint1" type="revolute">
    <parent link="base_link"/>
    <child link="link1"/>
    <origin xyz="0.0 0.0 0.2"/>
    <axis xyz="0.0 0.0 1.0"/>
    <limit lower="-3.14" upper="3.14" effort="100" velocity="2.0"/>
  </joint>

  <!-- Link 2 -->
  <link name="link2">
    <inertial>
      <origin xyz="0.0 0.0 0.25"/>
      <mass value="3.0"/>
      <inertia ixx="0.02" ixy="0.0" ixz="0.0"
               iyy="0.02" iyz="0.0"
               izz="0.02"/>
    </inertial>
    <visual>
      <origin xyz="0.0 0.0 0.25"/>
      <geometry>
        <cylinder radius="0.04" length="0.5"/>
      </geometry>
    </visual>
  </link>

  <!-- Joint 2 (Shoulder) -->
  <joint name="joint2" type="revolute">
    <parent link="link1"/>
    <child link="link2"/>
    <origin xyz="0.0 0.0 0.5"/>
    <axis xyz="0.0 1.0 0.0"/>
    <limit lower="-1.57" upper="1.57" effort="50" velocity="1.5"/>
  </joint>
</robot>
```

### Python Kinematics Implementation

**Forward Kinematics Calculation:**
```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState
from geometry_msgs.msg import TransformStamped
from tf2_ros import TransformBroadcaster
import numpy as np
import math

class ForwardKinematicsNode(Node):
    def __init__(self):
        super().__init__('forward_kinematics')

        # Robot parameters
        self.link1_length = 0.5
        self.link2_length = 0.5

        # Joint state subscriber
        self.joint_sub = self.create_subscription(
            JointState, 'joint_states', self.joint_state_callback, 10
        )

        # TF broadcaster
        self.tf_broadcaster = TransformBroadcaster(self)

        self.get_logger().info('Forward kinematics node initialized')

    def joint_state_callback(self, msg):
        """Calculate forward kinematics from joint states"""

        # Get joint angles
        joint1_angle = 0.0
        joint2_angle = 0.0

        if 'joint1' in msg.name:
            idx = msg.name.index('joint1')
            joint1_angle = msg.position[idx]

        if 'joint2' in msg.name:
            idx = msg.name.index('joint2')
            joint2_angle = msg.position[idx]

        # Calculate forward kinematics
        end_effector_pose = self.calculate_forward_kinematics(
            joint1_angle, joint2_angle
        )

        # Publish transforms
        self.publish_transforms(joint1_angle, joint2_angle, end_effector_pose)

    def calculate_forward_kinematics(self, theta1, theta2):
        """Calculate end-effector position using DH parameters"""

        # DH parameters for 2-DOF arm
        # Link 1: a1=0.5, alpha1=0, d1=0, theta1=theta1
        # Link 2: a2=0.5, alpha2=0, d2=0, theta2=theta2

        # Transformation matrices
        T1 = self.dh_transform(self.link1_length, 0, 0, theta1)
        T2 = self.dh_transform(self.link2_length, 0, 0, theta2)

        # Total transformation
        T_total = T1 @ T2

        # Extract position
        x = T_total[0, 3]
        y = T_total[1, 3]
        z = T_total[2, 3]

        return {'x': x, 'y': y, 'z': z}

    def dh_transform(self, a, alpha, d, theta):
        """Create DH transformation matrix"""

        ct = math.cos(theta)
        st = math.sin(theta)
        ca = math.cos(alpha)
        sa = math.sin(alpha)

        return np.array([
            [ct, -st*ca, st*sa, a*ct],
            [st, ct*ca, -ct*sa, a*st],
            [0, sa, ca, d],
            [0, 0, 0, 1]
        ])

    def publish_transforms(self, theta1, theta2, end_effector_pose):
        """Publish TF transforms for visualization"""

        # Base to link1 transform
        t1 = TransformStamped()
        t1.header.stamp = self.get_clock().now().to_msg()
        t1.header.frame_id = 'base_link'
        t1.child_frame_id = 'link1'
        t1.transform.translation.x = 0.0
        t1.transform.translation.y = 0.0
        t1.transform.translation.z = self.link1_length
        t1.transform.rotation.w = math.cos(theta1/2)
        t1.transform.rotation.x = 0.0
        t1.transform.rotation.y = math.sin(theta1/2)
        t1.transform.rotation.z = 0.0

        # Link1 to link2 transform
        t2 = TransformStamped()
        t2.header.stamp = self.get_clock().now().to_msg()
        t2.header.frame_id = 'link1'
        t2.child_frame_id = 'link2'
        t2.transform.translation.x = 0.0
        t2.transform.translation.y = 0.0
        t2.transform.translation.z = self.link2_length
        t2.transform.rotation.w = math.cos(theta2/2)
        t2.transform.rotation.x = 0.0
        t2.transform.rotation.y = math.sin(theta2/2)
        t2.transform.rotation.z = 0.0

        # End effector transform
        t3 = TransformStamped()
        t3.header.stamp = self.get_clock().now().to_msg()
        t3.header.frame_id = 'base_link'
        t3.child_frame_id = 'end_effector'
        t3.transform.translation.x = end_effector_pose['x']
        t3.transform.translation.y = end_effector_pose['y']
        t3.transform.translation.z = end_effector_pose['z']
        t3.transform.rotation.w = 1.0
        t3.transform.rotation.x = 0.0
        t3.transform.rotation.y = 0.0
        t3.transform.rotation.z = 0.0

        # Send transforms
        self.tf_broadcaster.sendTransform([t1, t2, t3])

def main():
    rclpy.init()
    node = ForwardKinematicsNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Testing and Validation

### URDF Validation Tools

**Check URDF Syntax:**
```bash
# Check URDF for syntax errors
check_urdf my_robot.urdf

# Display URDF structure
check_urdf --model my_robot.urdf

# Visualize URDF in RViz
ros2 run rviz2 rviz2 -d config/robot_view.rviz
```

**Joint State Publisher GUI:**
```bash
# Launch joint state publisher with GUI
ros2 run joint_state_publisher_gui joint_state_publisher_gui
ros2 param set /joint_state_publisher_gui use_gui true

# Load URDF parameter
ros2 param set /robot_state_publisher robot_description "$(cat my_robot.urdf)"
```

### Performance Optimization

**Mesh Optimization:**
```xml
<!-- Use simplified collision meshes -->
<collision>
  <geometry>
    <mesh filename="package://my_robot/modes/wheel_collision.stl"
          scale="1.0 1.0 1.0"/>
  </geometry>
</collision>

<!-- Use high-resolution visual meshes -->
<visual>
  <geometry>
    <mesh filename="package://my_robot/modes/wheel_visual.stl"
          scale="1.0 1.0 1.0"/>
  </geometry>
</visual>
```

**Level of Detail (LOD):**
```xml
<!-- Use different meshes for different purposes -->
<visual>
  <geometry>
    <mesh filename="package://my_robot/modes/wheel_high_res.stl"/>
  </geometry>
</visual>

<collision>
  <geometry>
    <!-- Simplified collision geometry -->
    <cylinder radius="0.1" length="0.05"/>
  </geometry>
</collision>
```

## Best Practices

### URDF Design Guidelines

**1. Use Consistent Naming:**
```xml
<!-- Good: descriptive names -->
<link name="left_front_wheel"/>
<joint name="left_front_wheel_joint"/>

<!-- Bad: generic names -->
<link name="link1"/>
<joint name="joint1"/>
```

**2. Separate Visual and Collision:**
```xml
<!-- Use different geometries for visual and collision -->
<visual>
  <geometry>
    <mesh filename="detailed_wheel.stl"/>
  </geometry>
</visual>

<collision>
  <geometry>
    <cylinder radius="0.1" length="0.05"/>
  </geometry>
</collision>
```

**3. Use Xacro for Reusability:**
```xml
<!-- Define reusable macros -->
<xacro:macro name="wheel" prefix="">
  <!-- Wheel definition -->
</xacro:macro>

<!-- Use macros -->
<xacro:wheel prefix="front_left"/>
<xacro:wheel prefix="front_right"/>
```

### Common Pitfalls and Solutions

**1. Incorrect Inertial Properties:**
```xml
<!-- Problem: Zero mass or inertia -->
<inertial>
  <mass value="0.0"/>  <!-- Wrong: causes simulation errors -->
</inertial>

<!-- Solution: Proper inertial properties -->
<inertial>
  <mass value="1.0"/>
  <inertia ixx="0.01" ixy="0.0" ixz="0.0"
           iyy="0.01" iyz="0.0"
           izz="0.01"/>
</inertial>
```

**2. Missing Joint Axes:**
```xml
<!-- Problem: Undefined joint axis -->
<joint name="wheel_joint" type="continuous">
  <!-- No axis defined -->
</joint>

<!-- Solution: Define rotation axis -->
<joint name="wheel_joint" type="continuous">
  <axis xyz="0.0 0.0 1.0"/>
</joint>
```

**3. Incorrect Transform Origins:**
```xml
<!-- Problem: Wrong joint origin -->
<joint name="arm_joint" type="revolute">
  <origin xyz="0.0 0.0 0.0"/>  <!-- Should be at joint center -->
</joint>

<!-- Solution: Correct joint placement -->
<joint name="arm_joint" type="revolute">
  <origin xyz="0.0 0.0 0.25"/>  <!-- At end of link -->
</joint>
```

## Next Steps

This comprehensive guide to URDF and robot modeling provides the foundation for creating accurate virtual robot representations. The next sections will cover:

1. **Simulation Integration**: Using URDF models in Gazebo and Isaac Sim
2. **Advanced Kinematics**: Inverse kinematics and motion planning
3. **Sensor Simulation**: Integrating sensors and camera systems
4. **Real-World Applications**: Connecting URDF models to physical robots

By mastering these URDF modeling techniques and best practices, you'll be equipped to create robust, accurate robot models for simulation, visualization, and control applications.